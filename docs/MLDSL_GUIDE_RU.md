# Руководство по MLDSL (RU)

Это руководство в стиле “как думает компилятор” для людей и для AI‑агентов, генерирующих `.mldsl`.

Важно: каталог действий (API) генерируется локально в `out/api_aliases.json` и **не коммитится** (см. `README.md`).

## Сборка API и документации

- `python tools/build_all.py`
  - собирает `out/actions_catalog.json`
  - собирает `out/api_aliases.json`
  - генерирует `out/docs/*` (локально)

## Базовый синтаксис

### События

```
event("Вход игрока") {
    player.message("Hello!")
}
```

### Функции

Поддерживаемые ключевые слова: `func`, `function`, `def`, `функция`.
Допустимы оба варианта: `func hello {}` и `func(hello) {}`.

```
func hello {
    player.message("Hi")
}
```

### Циклы

```
loop mycycle every 5 {
    player.message("tick")
}
```

### Вызов действий

Вызовы API имеют вид `module.func(args...)`. Аргументы могут быть:
- позиционными: `player.message("a", "b")`
- именованными: `player.message(text="a")` (если у функции есть `params` в API)

### Переменные и присваивание

Имена переменных могут содержать плейсхолдеры, например `%selected%counter`.

```
a = 1
save a = 1
a ~ 1               # короткая запись для save a = 1
%selected%counter = %selected%counter + 1
```

Числовые выражения ограничены операторами `+ - * /` с константами и именами (без вложенных вызовов).
Если выражение требует нескольких серверных действий, компилятор выводит предупреждение о дополнительных действиях.

### Условия `if`

```
if %selected%counter < 2 {
    player.message("low")
}
```

### Перечисления (enums / переключатели)

Некоторые действия имеют переключатели‑перечисления. В коде они передаются как `key=value`,
а компилятор преобразует это в `clicks(slot,n)=0` для `/placeadvanced`.

Поддерживается “человеческий сахар” для разделителя текста:
- `separator=""`
- `separator=" "`
- `separator="\\n"`

## Выборка (select / выборка)

Выборка — это смена “выбранной сущности”, на которую будут работать следующие действия.

Базовый синтаксис:

```
select.allplayers {
    player.message("hi")
}
```

То же по‑русски:

```
выборка.allplayers {
    игрок.сообщение("hi")
}
```

### Подсказки‑цепочки (домен)

Можно уточнять домен для автодополнения:
- `select.player.` — действия выбора игроков
- `select.entity.` — действия выбора сущностей
- `select.mob.` — действия выбора мобов
- `select.ifplayer.` / `select.ifmob.` — быстрые фильтры (если есть в твоём API)

Пример:

```
select.player.ifplayer.приседает {
    player.message("sneak")
}
```

Важно: блок `select { ... }` автоматически **восстанавливает выборку** после `}` (через внутренний стек компилятора).

## item(...) для GUI‑слотов

Некоторые действия (например “Выдать предметы”) работают через сундук параметров. Для таких слотов поддержан wrapper:

```
item("stone", count=3, meta=0, name="&aКамушек", description="строка1\\n&bстрока2", nbt={})
```

Где:
- `count` — количество (1..64)
- `meta` — meta/damage/data
- `name` — имя (цвета `&` → `§`)
- `description` — лор, строки разделяются `\\n`
- `nbt` — SNBT строкой (`{...}`)

Пример выдачи нескольких предметов:

```
игрок.выдать_предметы(
    item("stone", count=3),
    item("diamond", count=2)
)
```

## Что производит компилятор

Компилятор создаёт линейный план вида:

```
{ "block": "diamond_block", "name": "Вход игрока||Вход", "args": "no" }
{ "block": "cobblestone", "name": "Отправить сообщение||Сообщение", "args": "slot(9)=text(hi)" }
{ "block": "newline" }
```

Этот план исполняется модом через `/mldsl run "...\plan.json"`.

## Требования для печати

Для исполнения `plan.json` в игре нужен клиентский мод BetterCode (MLBetterCode):
- https://github.com/rainbownyashka/mlbettercode
